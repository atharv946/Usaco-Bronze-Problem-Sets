Game Stuck
[ Memory: 64 MB, CPU: 1 sec ]

Bessie is playing a game on her Cownsole! In the game, Bessie has a line of ğ‘(1â‰¤ğ‘â‰¤100)
 items, each with a unique integer ID from 1 to N. In the beginning, the items are sorted in ascending order, or in other words, item ğ‘–
 has ID ğ‘–
.

In one move, Bessie can take two indexes on the line, and reverse the order of the items in the middle. Normally, she can change the indexes with buttons, however the buttons are jammed! Now, the Cownsole only executes two moves in repetition- reversing between ğ´1
 and ğ´2
, and then reversing between ğµ1
 and ğµ2
, after.
Bessie estimates that it will take ğ¾(1â‰¤ğ¾â‰¤109)
 cycles, so 2ğ¾
 total moves, for the Cownsole to run out of battery. Now Bessie wonders, what is the last configuration of items before the Cownsole dies?

INPUT FORMAT:

The first line of input contains ğ‘
 and ğ¾
. The second line contains ğ´1
 and ğ´2
, and the third contains ğµ1
 and ğµ2
.

OUTPUT FORMAT:

On the ğ‘–
th line of output, print the label of the ğ‘–
th cow from the left at the end of the exercise routine.

SAMPLE INPUT:

5 2
1 2
2 5
SAMPLE OUTPUT:

5
1
3
4
2
To start, the cows are in ascending order.

1 2 3 4 5
After the each move, the cows look like

2 5 4 3 1
5 1 3 4 2


Code:

import java.util.*;
import java.io.*;

public class GameStuck {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        
        int N = scanner.nextInt();
        int K = scanner.nextInt(); 
        int A1 = scanner.nextInt();
        int A2 = scanner.nextInt();
        int B1 = scanner.nextInt();
        int B2 = scanner.nextInt();
        int [] cow = new int [N];
        int [] originalCow = new int[N];
        for(int i = 0 ; i < N ; i++){
            cow[i] = i + 1;
        }
        for(int i = 0 ; i < N ; i++){
            originalCow[i] = i + 1;
        }
        int cycleLen = 0;
        for(int i = 0 ; i < N * N ; i++){ 
            
            move(A1-1 , A2-1 ,cow);
            move(B1-1 , B2-1 , cow);
            cycleLen++;
            if(arraysEqual(cow , originalCow , N)){
                break;
            }
        }
        int needed = K % cycleLen; 
        for(int i = 0 ; i < needed ; i++){
            move(A1 -1 , A2 -1 ,originalCow);
            move(B1 -1 , B2 -1 , originalCow);
        }
        for(int i = 0 ; i < N ; i++){
            System.out.println(originalCow[i]);
        }
    }
    public static void move(int start , int end , int [] cow){
            if (start < end) {
                int middle = (end - start) / 2;
                for (int k = 0; k <= middle; k++) {
                    int first = cow[start + k];
                    cow[start+k] = cow[end-k];
                    cow[end-k] = first;
                }
            }
            else {
                return;
            }
    }
    public static boolean arraysEqual(int [] cow , int [] originalCow , int N){
        for(int i = 0 ; i < N ; i++){
            if(!(originalCow[i] == cow[i])){
                return false;
            }
        }
        return true;
    }
}
